<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sky Force: Raiden Legacy</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            /* Prevent pull-to-refresh on mobile */
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: #000;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.2);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 20px;
            color: #fff;
            text-shadow: 0 0 5px #00f;
            font-size: 20px;
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            letter-spacing: 1px;
        }

        #start-screen,
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            background: linear-gradient(to bottom, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(0, 100, 255, 0.8);
        }

        p {
            font-size: 18px;
            color: #ccc;
            margin-bottom: 30px;
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #0066cc, #0099ff);
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.6);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 150, 255, 0.8);
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        .controls-hint {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }

        #score-display {
            color: #0ff;
        }

        #health-bar-container {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #555;
            border-radius: 4px;
            overflow: hidden;
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #f00, #ff0, #0f0);
            width: 100%;
            transition: width 0.2s;
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div class="hud">
            <div>SCORE: <span id="score-display">0</span></div>
            <div id="health-bar-container">
                <div id="health-bar"></div>
            </div>
        </div>
        <div id="boss-hud" class="hidden"
            style="position: absolute; top: 60px; left: 50%; transform: translateX(-50%); width: 300px; text-align: center;">
            <div style="color: #f00; font-weight: bold; text-shadow: 0 0 5px #000; margin-bottom: 5px;">WARNING: BOSS
                APPROACHING</div>
            <div style="width: 100%; height: 15px; background: #333; border: 2px solid #f00; border-radius: 4px;">
                <div id="boss-health-bar" style="width: 100%; height: 100%; background: #f00; transition: width 0.2s;">
                </div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>Sky Force</h1>
        <p>Defend the airspace. Destroy all invaders.</p>
        <button id="start-btn">Start Mission</button>
        <div class="controls-hint">WASD / Arrows to Move â€¢ SPACE to Shoot</div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>Mission Failed</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn">Retry</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * Game Configuration & Constants
         */
        const CONFIG = {
            PLAYER_SPEED: 5,
            PLAYER_FIRE_RATE: 10, // Frames between shots
            BULLET_SPEED: 10,
            ENEMY_SPAWN_RATE: 60, // Frames between spawns (decreases over time)
            STAR_COUNT: 100,
            PARTICLE_DECAY: 0.02
        };

        /**
         * Core Game Engine
         */
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width = window.innerWidth > 600 ? 600 : window.innerWidth;
                this.height = this.canvas.height = window.innerHeight;

                this.state = 'START'; // START, PLAYING, GAMEOVER
                this.score = 0;
                this.frameCount = 0;

                this.keys = {};
                this.touch = { active: false, x: 0, y: 0 };

                // Entities
                this.player = null;
                this.bullets = [];
                this.enemies = [];
                this.particles = [];
                this.stars = [];
                this.powerups = [];

                // Systems
                this.initInput();
                this.initStars();

                // UI Elements
                this.ui = {
                    start: document.getElementById('start-screen'),
                    gameOver: document.getElementById('game-over-screen'),
                    score: document.getElementById('score-display'),
                    finalScore: document.getElementById('final-score'),
                    healthBar: document.getElementById('health-bar'),
                    startBtn: document.getElementById('start-btn'),
                    restartBtn: document.getElementById('restart-btn'),
                    bossHud: document.getElementById('boss-hud'),
                    bossHealthBar: document.getElementById('boss-health-bar')
                };

                this.ui.startBtn.addEventListener('click', () => this.start());
                this.ui.restartBtn.addEventListener('click', () => this.start());

                window.addEventListener('resize', () => {
                    this.width = this.canvas.width = window.innerWidth > 600 ? 600 : window.innerWidth;
                    this.height = this.canvas.height = window.innerHeight;
                    this.initStars(); // Re-init stars to cover new area
                });

                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            initInput() {
                window.addEventListener('keydown', e => this.keys[e.code] = true);
                window.addEventListener('keyup', e => this.keys[e.code] = false);

                // Touch controls for mobile
                this.canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    this.touch.active = true;
                    this.updateTouchPos(e);
                    // Auto-fire on mobile? Or tap to shoot? Let's auto-fire if touching.
                    this.keys['Space'] = true;
                }, { passive: false });

                this.canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    this.updateTouchPos(e);
                }, { passive: false });

                this.canvas.addEventListener('touchend', e => {
                    e.preventDefault();
                    this.touch.active = false;
                    this.keys['Space'] = false;
                });
            }

            updateTouchPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.touch.x = e.touches[0].clientX - rect.left;
                this.touch.y = e.touches[0].clientY - rect.top;
            }

            initStars() {
                this.stars = [];
                for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
                    this.stars.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        size: Math.random() * 2 + 0.5,
                        speed: Math.random() * 3 + 0.5
                    });
                }
            }

            spawnPowerUp(x, y) {
                if (Math.random() < 0.15) { // 15% chance
                    const rand = Math.random();
                    let type;
                    if (rand < 0.4) type = 'HEALTH';
                    else if (rand < 0.7) type = 'UPGRADE';
                    else type = 'MISSILE';

                    this.powerups.push(new PowerUp(x, y, type));
                }
            }

            start() {
                this.state = 'PLAYING';
                this.score = 0;
                this.frameCount = 0;
                this.player = new Player(this.width / 2, this.height - 100);
                this.bullets = [];
                this.enemies = [];
                this.particles = [];
                this.powerups = [];

                this.level = 1;
                this.levelProgress = 0;
                this.bossActive = false;
                this.boss = null;

                this.ui.start.classList.add('hidden');
                this.ui.gameOver.classList.add('hidden');
                this.ui.bossHud.classList.add('hidden');
                this.updateUI();
            }

            gameOver() {
                this.state = 'GAMEOVER';
                this.ui.finalScore.innerText = this.score;
                this.ui.gameOver.classList.remove('hidden');
            }

            updateUI() {
                this.ui.score.innerText = this.score;
                const hpPercent = Math.max(0, (this.player.hp / this.player.maxHp) * 100);
                this.ui.healthBar.style.width = `${hpPercent}%`;

                // Color change based on health
                if (hpPercent > 60) this.ui.healthBar.style.background = 'linear-gradient(90deg, #0f0, #0f0)';
                else if (hpPercent > 30) this.ui.healthBar.style.background = 'linear-gradient(90deg, #ff0, #ff0)';
                else this.ui.healthBar.style.background = 'linear-gradient(90deg, #f00, #f00)';

                // Boss UI
                if (this.bossActive && this.boss) {
                    this.ui.bossHud.classList.remove('hidden');
                    const bossHpPercent = Math.max(0, (this.boss.hp / this.boss.maxHp) * 100);
                    this.ui.bossHealthBar.style.width = `${bossHpPercent}%`;
                } else {
                    this.ui.bossHud.classList.add('hidden');
                }
            }

            spawnEnemy() {
                if (this.bossActive) return;

                // Level Progression
                this.levelProgress++;

                // Trigger Boss
                if (this.levelProgress > 1000 * this.level && !this.bossActive) {
                    this.spawnBoss();
                    return;
                }

                // Difficulty scaling
                const difficulty = Math.min(5, 1 + Math.floor(this.score / 1000));
                const spawnChance = Math.max(20, CONFIG.ENEMY_SPAWN_RATE - (difficulty * 5));

                if (this.frameCount % spawnChance === 0) {
                    const type = Math.random();
                    let enemy;

                    if (this.level === 1) {
                        if (type < 0.7) enemy = new BasicEnemy(Math.random() * (this.width - 30), -30);
                        else enemy = new FastEnemy(Math.random() * (this.width - 30), -30);
                    } else {
                        if (type < 0.4) enemy = new BasicEnemy(Math.random() * (this.width - 30), -30);
                        else if (type < 0.7) enemy = new FastEnemy(Math.random() * (this.width - 30), -30);
                        else enemy = new TankEnemy(Math.random() * (this.width - 50), -50);
                    }

                    this.enemies.push(enemy);
                }
            }

            spawnBoss() {
                this.bossActive = true;
                // Clear existing enemies
                this.enemies.forEach(e => {
                    this.createExplosion(e.x + e.width / 2, e.y + e.height / 2, 10, '#ff5500');
                    e.markedForDeletion = true;
                });

                if (this.level === 1) {
                    this.boss = new IronGuardian(this.width / 2 - 60, -150);
                } else {
                    this.boss = new CrimsonWing(this.width / 2 - 60, -150);
                }
                this.enemies.push(this.boss);
            }

            update() {
                if (this.state !== 'PLAYING') return;

                this.frameCount++;

                // Background
                this.stars.forEach(star => {
                    star.y += star.speed;
                    if (star.y > this.height) {
                        star.y = 0;
                        star.x = Math.random() * this.width;
                    }
                });

                // Player
                if (this.player) {
                    this.player.update(this);
                    if (this.player.markedForDeletion) {
                        this.createExplosion(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2, 50, '#0ff');
                        this.gameOver();
                    }
                }

                // Bullets
                this.bullets.forEach(b => b.update());
                this.bullets = this.bullets.filter(b => !b.markedForDeletion &&
                    b.y > -50 && b.y < this.height + 50 && b.x > -50 && b.x < this.width + 50);

                // Enemies
                this.spawnEnemy();
                this.enemies.forEach(e => e.update(this));
                this.enemies = this.enemies.filter(e => !e.markedForDeletion && e.y < this.height + 100);

                // Particles
                this.particles.forEach(p => p.update());
                this.particles = this.particles.filter(p => !p.markedForDeletion);

                // Powerups
                this.powerups.forEach(p => p.update());
                this.powerups = this.powerups.filter(p => !p.markedForDeletion && p.y < this.height + 50);

                // Collision Detection
                this.checkCollisions();

                // UI Update (occasionally to save perf)
                if (this.frameCount % 10 === 0) this.updateUI();
            }

            checkCollisions() {
                // Player Bullets vs Enemies
                this.bullets.filter(b => !b.isEnemy).forEach(bullet => {
                    this.enemies.forEach(enemy => {
                        if (this.checkRectCollision(bullet, enemy)) {
                            bullet.markedForDeletion = true;
                            enemy.takeDamage(1);
                            this.createExplosion(bullet.x, bullet.y, 5, '#ffaa00');
                            if (enemy.markedForDeletion) {
                                this.score += enemy.scoreValue;
                                this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 20, '#ff5500');
                                this.spawnPowerUp(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);

                                if (enemy === this.boss) {
                                    this.bossActive = false;
                                    this.boss = null;
                                    this.level++;
                                    this.levelProgress = 0;
                                    this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 100, '#ffffff');
                                    this.score += 5000; // Boss Bonus
                                }
                            }
                        }
                    });
                });

                // Player vs Powerups
                this.powerups.forEach(p => {
                    if (this.checkRectCollision(p, this.player)) {
                        p.markedForDeletion = true;
                        if (p.type === 'HEALTH') {
                            this.player.heal(30);
                            this.createExplosion(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2, 10, '#00ff00');
                        } else if (p.type === 'UPGRADE') {
                            this.player.upgradeWeapon();
                            this.createExplosion(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2, 10, '#00ffff');
                        } else if (p.type === 'MISSILE') {
                            this.player.enableMissiles();
                            this.createExplosion(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2, 10, '#ff00ff');
                        }
                        this.score += 50;
                    }
                });

                // Enemy Bullets vs Player
                this.bullets.filter(b => b.isEnemy).forEach(bullet => {
                    if (this.checkRectCollision(bullet, this.player)) {
                        bullet.markedForDeletion = true;
                        this.player.takeDamage(1);
                        this.createExplosion(bullet.x, bullet.y, 10, '#ff0000');
                    }
                });

                // Enemies vs Player (Crash)
                this.enemies.forEach(enemy => {
                    if (this.checkRectCollision(enemy, this.player)) {
                        enemy.markedForDeletion = true;
                        this.player.takeDamage(20); // Big damage for crashing
                        this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 30, '#ff5500');
                    }
                });
            }

            checkRectCollision(rect1, rect2) {
                return (
                    rect1.x < rect2.x + rect2.width &&
                    rect1.x + rect1.width > rect2.x &&
                    rect1.y < rect2.y + rect2.height &&
                    rect1.y + rect1.height > rect2.y
                );
            }

            createExplosion(x, y, count, color) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            draw() {
                // Clear screen with trail effect
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; // Slight trail
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Draw Stars
                this.ctx.fillStyle = '#ffffff';
                this.stars.forEach(star => {
                    this.ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.globalAlpha = 1.0;

                if (this.state === 'PLAYING' || this.state === 'GAMEOVER') {
                    // Draw Player
                    if (this.player && !this.player.markedForDeletion) this.player.draw(this.ctx);

                    // Draw Enemies
                    this.enemies.forEach(e => e.draw(this.ctx));

                    // Draw Bullets
                    this.bullets.forEach(b => b.draw(this.ctx));

                    // Draw Powerups
                    this.powerups.forEach(p => p.draw(this.ctx));

                    // Draw Particles
                    this.particles.forEach(p => p.draw(this.ctx));
                }
            }

            loop() {
                this.update();
                this.draw();
                requestAnimationFrame(this.loop);
            }
        }

        /**
         * Entities
         */
        class Entity {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.markedForDeletion = false;
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 40, 50);
                this.speed = CONFIG.PLAYER_SPEED;
                this.lastShot = 0;
                this.maxHp = 100;
                this.hp = this.maxHp;
                this.engineGlow = 0;
                this.weaponLevel = 1;
                this.hasMissiles = false;
                this.missileCount = 0;
                this.missileTimer = 0;
            }

            update(game) {
                // Movement
                if (game.keys['ArrowLeft'] || game.keys['KeyA']) this.x -= this.speed;
                if (game.keys['ArrowRight'] || game.keys['KeyD']) this.x += this.speed;
                if (game.keys['ArrowUp'] || game.keys['KeyW']) this.y -= this.speed;
                if (game.keys['ArrowDown'] || game.keys['KeyS']) this.y += this.speed;

                // Touch Movement
                if (game.touch.active) {
                    const targetX = game.touch.x - this.width / 2;
                    const targetY = game.touch.y - this.height / 2;
                    this.x += (targetX - this.x) * 0.2;
                    this.y += (targetY - this.y) * 0.2;
                }

                // Boundaries
                this.x = Math.max(0, Math.min(game.width - this.width, this.x));
                this.y = Math.max(0, Math.min(game.height - this.height, this.y));

                // Shooting
                if ((game.keys['Space'] || game.touch.active) && game.frameCount - this.lastShot > CONFIG.PLAYER_FIRE_RATE) {
                    this.shoot(game);
                }

                // Auto-fire missiles if unlocked
                if (this.hasMissiles) {
                    this.missileTimer++;
                    if (this.missileTimer > 60) { // Fire every second approx
                        for (let i = 0; i < this.missileCount; i++) {
                            // Stagger missile spawns slightly or spread them out
                            setTimeout(() => {
                                if (!game.player.markedForDeletion) {
                                    game.bullets.push(new SeekerMissile(this.x + this.width / 2, this.y, game));
                                }
                            }, i * 100);
                        }
                        this.missileTimer = 0;
                    }
                }

                // Engine flicker
                this.engineGlow = Math.random() * 0.5 + 0.5;
            }

            shoot(game) {
                // Weapon Levels
                if (this.weaponLevel === 1) {
                    // Double stream
                    game.bullets.push(new Bullet(this.x + 5, this.y, 0, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width - 10, this.y, 0, -CONFIG.BULLET_SPEED, false));
                } else if (this.weaponLevel === 2) {
                    // Triple stream
                    game.bullets.push(new Bullet(this.x + 5, this.y, 0, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width / 2 - 2.5, this.y - 10, 0, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width - 10, this.y, 0, -CONFIG.BULLET_SPEED, false));
                } else if (this.weaponLevel === 3) {
                    // Spread shot (Level 3)
                    game.bullets.push(new Bullet(this.x + 5, this.y, -1, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + 15, this.y, 0, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width - 20, this.y, 0, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width - 10, this.y, 1, -CONFIG.BULLET_SPEED, false));
                } else if (this.weaponLevel === 4) {
                    // Wide Spread (Level 4)
                    game.bullets.push(new Bullet(this.x + 5, this.y, -2, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + 5, this.y, -1, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width / 2, this.y - 10, 0, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width - 10, this.y, 1, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width - 10, this.y, 2, -CONFIG.BULLET_SPEED, false));
                } else {
                    // Doomsday Barrage (Level 5)
                    game.bullets.push(new Bullet(this.x, this.y + 10, -3, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + 5, this.y, -1.5, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + 10, this.y - 5, -0.5, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width / 2, this.y - 15, 0, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width - 10, this.y - 5, 0.5, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width - 5, this.y, 1.5, -CONFIG.BULLET_SPEED, false));
                    game.bullets.push(new Bullet(this.x + this.width, this.y + 10, 3, -CONFIG.BULLET_SPEED, false));
                }
                this.lastShot = game.frameCount;
            }

            heal(amount) {
                this.hp = Math.min(this.maxHp, this.hp + amount);
            }

            upgradeWeapon() {
                this.weaponLevel = Math.min(5, this.weaponLevel + 1);
            }

            enableMissiles() {
                this.hasMissiles = true;
                this.missileCount = Math.min(3, this.missileCount + 1);
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) this.markedForDeletion = true;
            }

            draw(ctx) {
                ctx.save();

                // Engine Trail
                ctx.fillStyle = `rgba(0, 255, 255, ${this.engineGlow})`;
                ctx.beginPath();
                ctx.moveTo(this.x + 10, this.y + this.height);
                ctx.lineTo(this.x + 20, this.y + this.height + 20);
                ctx.lineTo(this.x + 30, this.y + this.height);
                ctx.fill();

                // Ship Body (Procedural drawing)
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';

                // Wings
                ctx.fillStyle = '#ccc';
                ctx.beginPath();
                ctx.moveTo(this.x + 20, this.y + 10);
                ctx.lineTo(this.x + this.width, this.y + this.height - 10);
                ctx.lineTo(this.x + 20, this.y + this.height - 5);
                ctx.lineTo(this.x, this.y + this.height - 10);
                ctx.fill();

                // Fuselage
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(this.x + 20, this.y);
                ctx.lineTo(this.x + 25, this.y + this.height - 5);
                ctx.lineTo(this.x + 15, this.y + this.height - 5);
                ctx.fill();

                // Cockpit
                ctx.fillStyle = '#00aaff';
                ctx.fillRect(this.x + 18, this.y + 15, 4, 10);

                ctx.restore();
            }
        }

        class Bullet extends Entity {
            constructor(x, y, vx, vy, isEnemy) {
                super(x, y, 5, 15);
                this.vx = vx;
                this.vy = vy;
                this.isEnemy = isEnemy;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw(ctx) {
                ctx.save();
                ctx.fillStyle = this.isEnemy ? '#ff3333' : '#33ff33';
                ctx.shadowBlur = 10;
                ctx.shadowColor = ctx.fillStyle;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        }

        class SeekerMissile extends Entity {
            constructor(x, y, game) {
                super(x, y, 10, 20);
                this.vx = 0;
                this.vy = -2; // Initial upward velocity
                this.speed = 7;
                this.turnSpeed = 0.15;
                this.target = null;
                this.game = game;
                this.isEnemy = false;
                this.trailTimer = 0;
            }

            update() {
                // Find target if none
                if (!this.target || this.target.markedForDeletion) {
                    this.findTarget();
                }

                if (this.target) {
                    const dx = (this.target.x + this.target.width / 2) - (this.x + this.width / 2);
                    const dy = (this.target.y + this.target.height / 2) - (this.y + this.height / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        const targetVx = (dx / dist) * this.speed;
                        const targetVy = (dy / dist) * this.speed;

                        this.vx += (targetVx - this.vx) * this.turnSpeed;
                        this.vy += (targetVy - this.vy) * this.turnSpeed;
                    }
                }

                this.x += this.vx;
                this.y += this.vy;

                // Trail
                this.trailTimer++;
                if (this.trailTimer % 3 === 0) {
                    this.game.particles.push(new Particle(this.x + this.width / 2, this.y + this.height, '#aa00ff'));
                }
            }

            findTarget() {
                let minDist = Infinity;
                let closest = null;
                this.game.enemies.forEach(e => {
                    const dx = e.x - this.x;
                    const dy = e.y - this.y;
                    const dist = dx * dx + dy * dy;
                    if (dist < minDist) {
                        minDist = dist;
                        closest = e;
                    }
                });
                this.target = closest;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                const angle = Math.atan2(this.vy, this.vx) + Math.PI / 2;
                ctx.rotate(angle);

                ctx.fillStyle = '#ff00ff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff00ff';

                // Missile shape
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(5, 5);
                ctx.lineTo(0, 2);
                ctx.lineTo(-5, 5);
                ctx.fill();

                ctx.restore();
            }
        }

        class BasicEnemy extends Entity {
            constructor(x, y) {
                super(x, y, 30, 30);
                this.speed = 3;
                this.hp = 2;
                this.scoreValue = 100;
                this.color = '#ff8800';
            }

            update(game) {
                this.y += this.speed;

                // Simple shooting
                if (Math.random() < 0.01) {
                    game.bullets.push(new Bullet(this.x + this.width / 2 - 2.5, this.y + this.height, 0, 5, true));
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) this.markedForDeletion = true;
            }

            draw(ctx) {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;

                // Triangle shape
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y + this.height);
                ctx.lineTo(this.x + this.width, this.y);
                ctx.lineTo(this.x, this.y);
                ctx.fill();

                ctx.restore();
            }
        }

        class FastEnemy extends BasicEnemy {
            constructor(x, y) {
                super(x, y);
                this.speed = 6;
                this.hp = 1;
                this.scoreValue = 200;
                this.color = '#ff00ff';
                this.width = 20;
                this.height = 20;
                this.angle = 0;
            }

            update(game) {
                this.y += this.speed;
                this.x += Math.sin(this.y * 0.05) * 3; // Sine wave movement
            }

            draw(ctx) {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;

                // Dart shape
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y + this.height);
                ctx.lineTo(this.x + this.width, this.y);
                ctx.lineTo(this.x + this.width / 2, this.y + 5);
                ctx.lineTo(this.x, this.y);
                ctx.fill();

                ctx.restore();
            }
        }

        class TankEnemy extends BasicEnemy {
            constructor(x, y) {
                super(x, y);
                this.speed = 1.5;
                this.hp = 10;
                this.scoreValue = 500;
                this.color = '#00ff00';
                this.width = 50;
                this.height = 50;
            }

            update(game) {
                this.y += this.speed;
                // Spread shot
                if (Math.random() < 0.02) {
                    game.bullets.push(new Bullet(this.x + this.width / 2, this.y + this.height, 0, 4, true));
                    game.bullets.push(new Bullet(this.x + this.width / 2, this.y + this.height, -2, 4, true));
                    game.bullets.push(new Bullet(this.x + this.width / 2, this.y + this.height, 2, 4, true));
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Turret
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Boss extends Entity {
            constructor(x, y, color) {
                super(x, y, 120, 100);
                this.color = color;
                this.maxHp = 500;
                this.hp = this.maxHp;
                this.speed = 1;
                this.dir = 1;
                this.scoreValue = 5000;
                this.phase = 0;
                this.timer = 0;
            }

            update(game) {
                // Entrance
                if (this.y < 50) {
                    this.y += 1;
                    return;
                }

                // Hover movement
                this.x += this.speed * this.dir;
                if (this.x <= 0 || this.x + this.width >= game.width) {
                    this.dir *= -1;
                }

                this.timer++;
                this.attack(game);
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) this.markedForDeletion = true;
            }

            attack(game) {
                // Override in subclass
            }

            draw(ctx) {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;

                // Main Body
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 20, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class IronGuardian extends Boss {
            constructor(x, y) {
                super(x, y, '#888888');
                this.maxHp = 1000;
                this.hp = this.maxHp;
            }

            attack(game) {
                // Pattern 1: Spread Shot
                if (this.timer % 60 === 0) {
                    for (let i = -3; i <= 3; i++) {
                        game.bullets.push(new Bullet(this.x + this.width / 2, this.y + this.height, i * 1.5, 5, true));
                    }
                }

                // Pattern 2: Heavy Cannon
                if (this.timer % 120 === 0) {
                    game.bullets.push(new Bullet(this.x + 20, this.y + this.height, 0, 8, true));
                    game.bullets.push(new Bullet(this.x + this.width - 20, this.y + this.height, 0, 8, true));
                }
            }

            draw(ctx) {
                super.draw(ctx);
                // Extra armor details
                ctx.fillStyle = '#444';
                ctx.fillRect(this.x - 20, this.y + 20, 20, 60); // Left armor
                ctx.fillRect(this.x + this.width, this.y + 20, 20, 60); // Right armor
            }
        }

        class CrimsonWing extends Boss {
            constructor(x, y) {
                super(x, y, '#ff0000');
                this.maxHp = 1500;
                this.hp = this.maxHp;
                this.speed = 2;
            }

            attack(game) {
                // Pattern 1: Spiral
                if (this.timer % 5 === 0) {
                    const angle = this.timer * 0.1;
                    const vx = Math.cos(angle) * 5;
                    const vy = Math.sin(angle) * 5;
                    game.bullets.push(new Bullet(this.x + this.width / 2, this.y + this.height / 2, vx, vy, true));
                }

                // Pattern 2: Burst
                if (this.timer % 100 === 0) {
                    for (let i = 0; i < 10; i++) {
                        game.bullets.push(new Bullet(this.x + Math.random() * this.width, this.y + this.height, 0, Math.random() * 3 + 3, true));
                    }
                }
            }

            draw(ctx) {
                super.draw(ctx);
                // Wing details
                ctx.fillStyle = '#aa0000';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - 40, this.y + 40);
                ctx.lineTo(this.x, this.y + 80);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(this.x + this.width, this.y);
                ctx.lineTo(this.x + this.width + 40, this.y + 40);
                ctx.lineTo(this.x + this.width, this.y + 80);
                ctx.fill();
            }
        }

        class PowerUp extends Entity {
            constructor(x, y, type) {
                super(x, y, 20, 20);
                this.type = type; // 'HEALTH' or 'UPGRADE'
                this.vy = 2;
                this.pulse = 0;
            }

            update() {
                this.y += this.vy;
                this.pulse += 0.1;
            }

            draw(ctx) {
                ctx.save();
                ctx.shadowBlur = 10;
                const scale = 1 + Math.sin(this.pulse) * 0.1;

                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.scale(scale, scale);

                if (this.type === 'HEALTH') {
                    ctx.fillStyle = '#00ff00';
                    ctx.shadowColor = '#00ff00';
                    // Cross shape
                    ctx.fillRect(-10, -3, 20, 6);
                    ctx.fillRect(-3, -10, 6, 20);
                } else if (this.type === 'UPGRADE') {
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowColor = '#00ffff';
                    // P shape or Up arrow
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(8, 0);
                    ctx.lineTo(4, 0);
                    ctx.lineTo(4, 10);
                    ctx.lineTo(-4, 10);
                    ctx.lineTo(-4, 0);
                    ctx.lineTo(-8, 0);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#ff00ff';
                    ctx.shadowColor = '#ff00ff';
                    // M shape
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('M', 0, 2);
                }

                ctx.restore();
            }
        }
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 3 + 1;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.life = 1.0;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= CONFIG.PARTICLE_DECAY;
                if (this.life <= 0) this.markedForDeletion = true;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Start the game
        window.onload = () => {
            const game = new Game();
        };

    </script>
</body>

</html>